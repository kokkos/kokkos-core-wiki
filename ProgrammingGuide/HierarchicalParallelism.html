<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="9. Custom Reductions" href="Custom-Reductions.html" /><link rel="prev" title="7. Parallel dispatch" href="ParallelDispatch.html" />

    <meta name="generator" content="sphinx-5.0.1, furo 2022.06.04.1"/>
        <title>8. Hierarchical Parallelism - Kokkos documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=40978830699223671f4072448e654b5958f38b89" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/hacks.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">Kokkos  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">Kokkos  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../programmingguide.html">Programming Guide</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Introduction.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Machine-Model.html">2. Machine Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="ProgrammingModel.html">3: Programming Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiling.html">4. Compiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html">5. Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="View.html">6: View: Multidimensional array</a></li>
<li class="toctree-l2"><a class="reference internal" href="ParallelDispatch.html">7. Parallel dispatch</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">8. Hierarchical Parallelism</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="Custom-Reductions.html">9. Custom Reductions</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="Custom-Reductions-Built-In-Reducers.html">9.1 Built-In-Reducers</a></li>
<li class="toctree-l3"><a class="reference internal" href="Custom-Reductions-Built-In-Reducers-with-Custom-Scalar-Types.html">9.2 Built-In Reducers with Custom Scalar Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="Custom-Reductions-Custom-Reducers.html">9.3 Custom Reducers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Atomic-Operations.html">10. Atomic Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subviews.html">11: Subviews</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compatibility.html">12 Backwards &amp; Future Compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="Interoperability.html">13. Interoperability and Legacy Codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="Kokkos-and-Virtual-Functions.html">14. Kokkos and Virtual Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../building.html">Build, Install and Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../keywords.html">CMake Keywords</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../API/core-index.html">API: Core</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/Initialize-and-Finalize.html">Initialize and Finalize</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/initialize_finalize/initialize.html">initialize</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/initialize_finalize/finalize.html">finalize</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/initialize_finalize/ScopeGuard.html">ScopeGuard</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/initialize_finalize/InitializationSettings.html">InitializationSettings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/initialize_finalize/InitArguments.html">InitArguments</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/View.html">View and related</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/create_mirror.html"><code class="docutils literal notranslate"><span class="pre">create_mirror[_view]</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/deep_copy.html"><code class="docutils literal notranslate"><span class="pre">deep_copy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/layoutLeft.html"><code class="docutils literal notranslate"><span class="pre">LayoutLeft</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/layoutRight.html"><code class="docutils literal notranslate"><span class="pre">LayoutRight</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/layoutStride.html"><code class="docutils literal notranslate"><span class="pre">LayoutStride</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/realloc.html"><code class="docutils literal notranslate"><span class="pre">realloc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/resize.html"><code class="docutils literal notranslate"><span class="pre">resize</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/subview.html"><code class="docutils literal notranslate"><span class="pre">subview</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/view.html"><code class="docutils literal notranslate"><span class="pre">View</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/view_alloc.html"><code class="docutils literal notranslate"><span class="pre">view_alloc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/view/view_like.html">View-like Types</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/ParallelDispatch.html">Parallel Execution/Dispatch</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/parallel-dispatch/parallel_for.html"><code class="docutils literal notranslate"><span class="pre">parallel_for()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/parallel-dispatch/parallel_reduce.html"><code class="docutils literal notranslate"><span class="pre">parallel_reduce()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/parallel-dispatch/parallel_scan.html"><code class="docutils literal notranslate"><span class="pre">parallel_scan()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/parallel-dispatch/fence.html"><code class="docutils literal notranslate"><span class="pre">fence()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/parallel-dispatch/ParallelForTag.html"><code class="docutils literal notranslate"><span class="pre">ParallelForTag()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/parallel-dispatch/ParallelReduceTag.html"><code class="docutils literal notranslate"><span class="pre">ParallelReduceTag()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/parallel-dispatch/ParallelScanTag.html"><code class="docutils literal notranslate"><span class="pre">ParallelScanTag()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/builtin_reducers.html">Built-in Reducers</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/ReducerConcept.html"><code class="docutils literal notranslate"><span class="pre">ReducerConcept</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/BAnd.html"><code class="docutils literal notranslate"><span class="pre">BAnd</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/BOr.html"><code class="docutils literal notranslate"><span class="pre">BOr</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/LAnd.html"><code class="docutils literal notranslate"><span class="pre">LAnd</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/LOr.html"><code class="docutils literal notranslate"><span class="pre">LOr</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/Max.html"><code class="docutils literal notranslate"><span class="pre">Max</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/MaxLoc.html"><code class="docutils literal notranslate"><span class="pre">MaxLoc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/Min.html"><code class="docutils literal notranslate"><span class="pre">Min</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/MinLoc.html"><code class="docutils literal notranslate"><span class="pre">MinLoc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/MinMax.html"><code class="docutils literal notranslate"><span class="pre">MinMax</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/MinMaxLoc.html"><code class="docutils literal notranslate"><span class="pre">MinMaxLoc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/Prod.html"><code class="docutils literal notranslate"><span class="pre">Prod</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/builtinreducers/Sum.html"><code class="docutils literal notranslate"><span class="pre">Sum</span></code></a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../API/core/builtinreducers/ReductionScalarTypes.html">Reduction Scalar Types</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../API/core/builtinreducers/MinMaxLocScalar.html"><code class="docutils literal notranslate"><span class="pre">MinMaxLocScalar</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../API/core/builtinreducers/MinMaxScalar.html"><code class="docutils literal notranslate"><span class="pre">MinMaxScalar</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../API/core/builtinreducers/ValLocScalar.html"><code class="docutils literal notranslate"><span class="pre">ValLocScalar</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/Execution-Policies.html">Execution Policies</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/policies/ExecutionPolicyConcept.html"><code class="docutils literal notranslate"><span class="pre">ExecutionPolicy</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/policies/MDRangePolicy.html"><code class="docutils literal notranslate"><span class="pre">MDRangePolicy</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/policies/NestedPolicies.html"><code class="docutils literal notranslate"><span class="pre">NestedPolicies</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/policies/RangePolicy.html"><code class="docutils literal notranslate"><span class="pre">RangePolicy</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/policies/TeamHandleConcept.html"><code class="docutils literal notranslate"><span class="pre">TeamHandleConcept</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/policies/TeamPolicy.html"><code class="docutils literal notranslate"><span class="pre">TeamPolicy</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/policies/TeamThreadRange.html"><code class="docutils literal notranslate"><span class="pre">TeamThreadRange</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/policies/TeamVectorRange.html"><code class="docutils literal notranslate"><span class="pre">TeamVectorRange</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/policies/ThreadVectorRange.html"><code class="docutils literal notranslate"><span class="pre">ThreadVectorRange</span></code></a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/Spaces.html">Spaces</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/execution_spaces.html">Execution Spaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/memory_spaces.html">Memory Spaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/SpaceAccessibility.html">Space Accessibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../API/core/Task-Parallelism.html">Task-Parallelism</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/atomics.html">Atomics</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/atomics/atomic_compare_exchange.html"><code class="docutils literal notranslate"><span class="pre">atomic_compare_exchange</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/atomics/atomic_compare_exchange_strong.html"><code class="docutils literal notranslate"><span class="pre">atomic_compare_exchange_strong</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/atomics/atomic_exchange.html"><code class="docutils literal notranslate"><span class="pre">atomic_exchange</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/atomics/atomic_fetch_op.html"><code class="docutils literal notranslate"><span class="pre">atomic_fetch_[op]</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/atomics/atomic_load.html"><code class="docutils literal notranslate"><span class="pre">atomic_load</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/atomics/atomic_op.html"><code class="docutils literal notranslate"><span class="pre">atomic_[op]</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/atomics/atomic_op_fetch.html"><code class="docutils literal notranslate"><span class="pre">atomic_[op]_fetch</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/atomics/atomic_store.html"><code class="docutils literal notranslate"><span class="pre">atomic_store</span></code></a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/Numerics.html">Numerics</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/numerics/mathematical-constants.html">Mathematical constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/numerics/mathematical-functions.html">Common math functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/numerics/numeric-traits.html">Numeric traits</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/c_style_memory_management.html">C-style memory management</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/c_style_memory_management/malloc.html"><code class="docutils literal notranslate"><span class="pre">kokkos_malloc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/c_style_memory_management/realloc.html"><code class="docutils literal notranslate"><span class="pre">kokkos_realloc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/c_style_memory_management/free.html"><code class="docutils literal notranslate"><span class="pre">kokkos_free</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../API/core/Traits.html">Traits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/core/KokkosConcepts.html">Kokkos Concepts</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/STL-Compatibility.html">STL Compatibility Issues</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/stl-compat/pair.html"><code class="docutils literal notranslate"><span class="pre">Kokkos::pair</span></code></a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/core/Utilities.html">Utilities</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/core/utilities/abort.html"><code class="docutils literal notranslate"><span class="pre">Kokkos::abort</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/utilities/all.html"><code class="docutils literal notranslate"><span class="pre">Kokkos::ALL</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/utilities/complex.html"><code class="docutils literal notranslate"><span class="pre">Kokkos::complex</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/utilities/timer.html"><code class="docutils literal notranslate"><span class="pre">Kokkos::Timer</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/core/utilities/experimental.html"><code class="docutils literal notranslate"><span class="pre">Kokkos::Experimental</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../API/core/Detection-Idiom.html">Detection Idiom</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/core/Macros.html">Macros</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../API/containers-index.html">API: Containers</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/Bitset.html"><code class="docutils literal notranslate"><span class="pre">Bitset</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/Bitset.html#constbitset"><code class="docutils literal notranslate"><span class="pre">ConstBitset</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/DualView.html"><code class="docutils literal notranslate"><span class="pre">DualView</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/DynamicView.html"><code class="docutils literal notranslate"><span class="pre">DynamicView</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/DynRankView.html"><code class="docutils literal notranslate"><span class="pre">DynRankView</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/Offset-View.html"><code class="docutils literal notranslate"><span class="pre">OffsetView</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/ScatterView.html"><code class="docutils literal notranslate"><span class="pre">ScatterView</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/StaticCrsGraph.html"><code class="docutils literal notranslate"><span class="pre">StaticCrsGraph</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/Unordered-Map.html"><code class="docutils literal notranslate"><span class="pre">UnorderedMap</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/containers/vector.html"><code class="docutils literal notranslate"><span class="pre">vector</span></code></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../API/algorithms-index.html">API: Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../API/algorithms/Random-Number.html">Random-Number</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/algorithms/Random-Number.html#generator">Generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../API/algorithms/Sort.html">Sort</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../API/algorithms/std-algorithms-index.html">Std Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" role="switch" type="checkbox"/><label for="toctree-checkbox-18"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../API/algorithms/std-algorithms/Iterators.html">Iterators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/algorithms/std-algorithms/StdMinMaxElement.html">Minimum/maximum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/algorithms/std-algorithms/StdModSeq.html">Modifying Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/algorithms/std-algorithms/StdNonModSeq.html">NonModifying Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/algorithms/std-algorithms/StdNumeric.html">Numeric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/algorithms/std-algorithms/StdPartioningOps.html">Partitioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API/algorithms/std-algorithms/StdSorting.html">Sorting</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../API/alphabetical.html">API in Alphabetical Order</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../usecases.html">Use Cases and Examples</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" role="switch" type="checkbox"/><label for="toctree-checkbox-19"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../usecases/MPI-Halo-Exchange.html">MPI Halo Exchange</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usecases/Average-To-Nodes.html">ScatterView averaging elements to nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usecases/MDRangePolicy.html">MDRangePolicy Use Case</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usecases/VirtualFunctions.html">Virtual Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usecases/TaggedOperators.html">Tagged Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usecases/OverlappingHostAndDeviceWork.html">Overlapping Host and Device work</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usecases/Tasking.html">Kokkos Tasking Use Case</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usecases/Kokkos-Fortran-Interoperability.html">Fortran Interop Use Case</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usecases/SoA-and-AoSoA-with-Cabana.html">Array of Structures and Structure of Arrays with Cabana</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../testing-and-issue-tracking.html">Testing and Issue Tracking</a><input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" role="switch" type="checkbox"/><label for="toctree-checkbox-20"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../testing-and-issue-tracking/Requirements-Issues-and-Feedback.html">Requirements, Issues and Feedback</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing-and-issue-tracking/Testing-Process-Details.html">Attachments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing-and-issue-tracking/Testing-Processes.html">Kokkos Testing Processes and Change Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing-and-issue-tracking/Testing-Workflow-Components.html">Kokkos Testing Workflow Components</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/kokkos/kokkos-tutorials">Tutorials</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../videolectures.html">Video lectures</a><input class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" role="switch" type="checkbox"/><label for="toctree-checkbox-21"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference external" href="https://www.youtube.com/watch?v=rUIcWtFU5qM">1. Intro, Build, Parallel dispatch</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.youtube.com/watch?v=O-asHTtO7O4">2. Views and Spaces</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.youtube.com/watch?v=nGyJS8u-6GY">3. Multidim loops and Data Structures</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.youtube.com/watch?v=s9ecpeWRePs">4. Hierarchical Parallelism</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.youtube.com/watch?v=xEAyOod57-c">5. SIMD, Streams, Tasking</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.youtube.com/watch?v=1J3JQ3d3cRc&amp;t=1s">6. Fortran/Python interop, MPI, PGAS</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.youtube.com/watch?v=MH6zFYGw0HU">7. Kokkos Tools</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.youtube.com/watch?v=_qD4X66MQF8&amp;t=1s">8. Kokkos Kernels Math Library</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/kokkos/kokkos">GitHub Repo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citation.html">Citing Kokkos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
<div class="edit-this-page">
  <a class="muted-link" href="https://github.com/kokkos/kokkos-core-wiki/blob/main/docs/source/ProgrammingGuide/HierarchicalParallelism.md" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4"></path>
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5"></line>
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div>

          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="hierarchical-parallelism">
<h1>8. Hierarchical Parallelism<a class="headerlink" href="#hierarchical-parallelism" title="Permalink to this heading">#</a></h1>
<p>This chapter explains how to use Kokkos to exploit multiple levels of shared-memory parallelism. These levels include thread teams, threads within a team, and vector lanes. You may nest these levels of parallelism, and execute <a class="reference internal" href="../API/core/parallel-dispatch/parallel_for.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">parallel_for()</span></code></span></a>, <a class="reference internal" href="../API/core/parallel-dispatch/parallel_reduce.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">parallel_reduce()</span></code></span></a>, or <a class="reference internal" href="../API/core/parallel-dispatch/parallel_scan.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">parallel_scan()</span></code></span></a> at each level. The syntax differs only by the execution policy,
which is the first argument to the <code class="docutils literal notranslate"><span class="pre">parallel_*</span></code> operation. Kokkos also exposes a “scratch pad” memory which provides thread private and team private allocations.</p>
<section id="motivation">
<h2>8.1 Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading">#</a></h2>
<p>Node architectures on modern high-performance computers are characterized by ever more <em>hierarchical parallelism</em>.
A level in the hierarchy is determined by the hardware resources which are shared between compute units at that level.
Higher levels in the hierarchy also have access to all resources in its branch at lower levels of the hierarchy.
This concept is orthogonal to the concept of heterogeneity. For example, a node in a typical CPU-based cluster consists of a number of multicore CPUs.  Each core supports one or more hyper-threads, and each hyper-thread can execute vector instructions. This means there are 4 levels in the hierarchy of parallelism:</p>
<ol class="arabic simple">
<li><p>CPU sockets share access to the same memory and network resources,</p></li>
<li><p>cores within a socket typically have a shared last level cache (LLC),</p></li>
<li><p>hyper-threads on the same core have access to a shared L1 (and L2) cache and they submit instructions to the same execution units, and</p></li>
<li><p>vector units execute a shared instruction on multiple data items.</p></li>
</ol>
<p>GPU-based systems also have a hierarchy of 4 levels:</p>
<ol class="arabic simple">
<li><p>multiple GPUs in the same node share access to the same host memory and network resources,</p></li>
<li><p>core clusters (e.g. the SMs on an NVIDIA GPU) have a shared cache and access to the same high bandwidth memory on a single GPU,</p></li>
<li><p>threads running on the same core cluster have access to the same L1 cache and scratch memory and</p></li>
<li><p>they are grouped in so-called Warps or Wave Fronts within which threads are always synchronous and can collaborate more closely, for example via direct register swapping.</p></li>
</ol>
<p>Kokkos provides a number of abstract levels of parallelism, which it maps to the appropriate hardware features. This mapping is not necessarily static or predefined; it may differ for each kernel. Furthermore, some mapping decisions happen at run time. This enables adaptive kernels which map work to different hardware resources depending on the work set size. While Kokkos provides defaults and suggestions, the optimal mapping can be algorithm dependent. Hierarchical parallelism is accessible through execution policies.</p>
<p>You should use Hierarchical Parallelism in particular in a number of cases:</p>
<ol class="arabic simple">
<li><p>Non-tightly nested loops: Hierarchical Parallelism allows you to expose more parallelism.</p></li>
<li><p>Data gather + reuse: If you gather data for a particular iteration of an outer loop, and then repeatably use it in an inner loop, Hierarchical Parallelism with scratch memory may match the use case well.</p></li>
<li><p>Force Cache Blocking: Using Hierarchical Parallelism forces a developer into algorithmic choices which are good for cache blocking. This can sometimes lead to better performing algorithms than a simple flat parallelism.</p></li>
</ol>
<p>On the other hand you should probably not use Hierarchical Parallelism if you have tightly nested loops. For that use case, a multidimensional Range Policy is the better fit.</p>
</section>
<section id="thread-teams">
<span id="hp-thread-teams"></span><h2>8.2 Thread teams<a class="headerlink" href="#thread-teams" title="Permalink to this heading">#</a></h2>
<p>Kokkos’ most basic hierarchical parallelism concept is a thread team. A <em>thread team</em> is a collection of threads which can synchronize and which share a “scratch pad” memory (see <a class="reference internal" href="#team-scratch-pad-memory"><span class="std std-ref">Section 8.3</span></a>).</p>
<p>Instead of mapping a 1-D range of indices to hardware resources, Kokkos’ thread teams map a 2-D index range. The first index is the <em>league rank</em>, the index of the team. The second index is the <em>team rank</em>, the thread index within a team. In CUDA this is equivalent to launching a 1-D grid of 1-D blocks. The league size is arbitrary – that is, it is only limited by the integer size type – while the team size must fit in the hardware constraints. As in CUDA, only a limited number of teams are actually active at the same time, and they must run to completion before new ones are executed. Consequently, it is not valid to use inter thread-team synchronization mechanisms such as waits for events initiated by other thread teams.</p>
<section id="creating-a-policy-instance">
<h3>8.2.1 Creating a Policy instance<a class="headerlink" href="#creating-a-policy-instance" title="Permalink to this heading">#</a></h3>
<p>Kokkos exposes use of thread teams with the <a class="reference internal" href="../API/core/policies/TeamPolicy.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">Kokkos::TeamPolicy</span></code></span></a> execution policy. To use thread teams you need to create a <a class="reference internal" href="../API/core/policies/TeamPolicy.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">Kokkos::TeamPolicy</span></code></span></a> instance. It can be created inline for the parallel dispatch call. The constructors require two arguments: a league size and a team size. In place of the team size, a user can utilize <code class="docutils literal notranslate"><span class="pre">Kokkos::AUTO</span></code> to let Kokkos guess a good team size for a given architecture. Doing that is the recommended way for most developers to utilize the <a class="reference internal" href="../API/core/policies/TeamPolicy.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamPolicy</span></code></span></a>. As with the  <a class="reference internal" href="../API/core/policies/RangePolicy.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">Kokkos::RangePolicy</span></code></span></a> a specific execution tag, a specific execution space, a <code class="docutils literal notranslate"><span class="pre">Kokkos::IndexType</span></code>, and a <code class="docutils literal notranslate"><span class="pre">Kokkos::Schedule</span></code> can be given as optional template arguments.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Using default execution space and launching</span>
<span class="c1">// a league with league_size teams with team_size threads each</span>
<span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">policy</span><span class="p">(</span><span class="w"> </span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c1">// Using  a specific execution space to</span>
<span class="c1">// run an n_workset parallelism with Kokkos choosing the team size</span>
<span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="n">ExecutionSpace</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">policy</span><span class="p">(</span><span class="w"> </span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">AUTO</span><span class="p">()</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c1">// Using a specific execution space and an execution tag</span>
<span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="n">SomeTag</span><span class="p">,</span><span class="w"> </span><span class="n">ExecutionSpace</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">policy</span><span class="p">(</span><span class="w"> </span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="basic-kernels">
<h3>8.2.2 Basic kernels<a class="headerlink" href="#basic-kernels" title="Permalink to this heading">#</a></h3>
<p>The team policy’s <code class="docutils literal notranslate"><span class="pre">member_type</span></code> provides the necessary functionality to use teams within a parallel kernel. It allows access to thread identifiers such as the league rank and size, and the team rank and size. It also provides team-synchronous actions such as team barriers, reductions and scans.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_for</span><span class="p">;</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="n">ExecutionSpace</span><span class="o">&gt;::</span><span class="n">member_type</span><span class="w"> </span><span class="n">member_type</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Create an instance of the policy</span>
<span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="n">ExecutionSpace</span><span class="o">&gt;</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">AUTO</span><span class="p">()</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="c1">// Launch a kernel</span>
<span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">policy</span><span class="p">,</span><span class="w"> </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="n">member_type</span><span class="w"> </span><span class="n">team_member</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Calculate a global thread id</span>
<span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">team_member</span><span class="p">.</span><span class="n">league_rank</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">team_member</span><span class="p">.</span><span class="n">team_size</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">            </span><span class="n">team_member</span><span class="p">.</span><span class="n">team_rank</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Calculate the sum of the global thread ids of this team</span>
<span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">team_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">team_member</span><span class="p">.</span><span class="n">reduce</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="c1">// Atomically add the value to a global value</span>
<span class="w">     </span><span class="n">a</span><span class="p">()</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">team_sum</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>The name <a class="reference internal" href="../API/core/policies/TeamPolicy.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamPolicy</span></code></span></a> makes it explicit that a kernel using it constitutes a parallel region with respect to the team.</p>
<p>In order to allow for coordination of work between members of a team, i.e. some threads compute a value, store it in global memory and then everyone consumes it, teams provide barriers. These barriers are collectives for all team members in the same team, but have no relationship with other teams. Here is an example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_for</span><span class="p">;</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="n">ExecutionSpace</span><span class="o">&gt;::</span><span class="n">member_type</span><span class="w"> </span><span class="n">member_type</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Create an instance of the policy</span>
<span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="n">ExecutionSpace</span><span class="o">&gt;</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">AUTO</span><span class="p">()</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="c1">// Launch a kernel</span>
<span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">policy</span><span class="p">,</span><span class="w"> </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="n">member_type</span><span class="w"> </span><span class="n">team_member</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Thread 0 in each team gathers some data via indirection.</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">team_member</span><span class="p">.</span><span class="n">team_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">a</span><span class="p">(</span><span class="n">team_member</span><span class="p">.</span><span class="n">league_rank</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">indices</span><span class="p">(</span><span class="n">team_member</span><span class="p">.</span><span class="n">league_rank</span><span class="p">()));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Now do a barrier for every team member to wait for a to be updated</span>
<span class="w">    </span><span class="n">team_member</span><span class="p">.</span><span class="n">team_barrier</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Now a can be used by every team member</span>
<span class="w">    </span><span class="n">c</span><span class="p">(</span><span class="n">team_member</span><span class="p">.</span><span class="n">league_rank</span><span class="p">(),</span><span class="n">team_member</span><span class="p">.</span><span class="n">team_rank</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">team_member</span><span class="p">.</span><span class="n">league_rank</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="team-scratch-pad-memory">
<span id="id1"></span><h2>8.3 Team scratch pad memory<a class="headerlink" href="#team-scratch-pad-memory" title="Permalink to this heading">#</a></h2>
<p>Each Kokkos team has a “scratch pad.” This is an instance of a memory space accessible only by threads in that team. Scratch pads let an algorithm load a workset into a shared space and then collaboratively work on it with all members of a team. The lifetime of data in a scratch pad is the lifetime of the team. In particular, scratch pads are recycled by all logical teams running on the same physical set of cores. During the lifetime of the team all operations allowed on global memory are allowed on the scratch memory. This includes taking addresses and performing atomic operations on elements located in scratch space. Team-level scratch pads correspond to the per-block shared memory in Cuda, or to the “local store” memory on the Cell processor.</p>
<p>Kokkos exposes scratch pads through a special memory space associated with the execution space: <code class="docutils literal notranslate"><span class="pre">execution_space::scratch_memory_space</span></code>. You may allocate a chunk of scratch memory through the <a class="reference internal" href="../API/core/policies/TeamPolicy.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamPolicy</span></code></span></a> member type. You may request multiple allocations from scratch, up to a user-provided maximum aggregate size. The maximum is provided either through a <code class="docutils literal notranslate"><span class="pre">team_shmem_size</span></code> function in the functor which returns a potentially team-size dependent value, or it can be specified through a setting of the TeamPolicy <code class="docutils literal notranslate"><span class="pre">set_scratch_size</span></code>. It is not valid to provide both values at the same time. The argument to the TeamPolicy can be used to set the shared memory size when using functors. One restriction on shared memory allocations is that they can not be freed during the lifetime of the team. This avoids the complexity of a memory pool, and reduces the time it takes to obtain an allocation (which currently is a few tens of integer operations to calculate the offset).</p>
<p>The following is an example of using the functor interface:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ExecutionSpace</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">functor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="n">ExecutionSpace</span><span class="w"> </span><span class="n">execution_space</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="n">execution_space</span><span class="o">::</span><span class="n">member_type</span><span class="w"> </span><span class="n">member_type</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">KOKKOS_INLINE_FUNCTION</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="n">member_type</span><span class="w"> </span><span class="n">team_member</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">double_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="o">*</span><span class="n">team_member</span><span class="p">.</span><span class="n">team_size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Get a shared team allocation on the scratch pad</span>
<span class="w">    </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">team_shared_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">team_member</span><span class="p">.</span><span class="n">team_shmem</span><span class="p">().</span><span class="n">get_shmem</span><span class="p">(</span><span class="n">double_size</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Get another allocation on the scratch pad</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">team_shared_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">team_member</span><span class="p">.</span><span class="n">team_shmem</span><span class="p">().</span><span class="n">get_shmem</span><span class="p">(</span><span class="mi">160</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ... use the scratch allocations ...</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Provide the shared memory capacity.</span>
<span class="w">  </span><span class="c1">// This function takes the team_size as an argument,</span>
<span class="w">  </span><span class="c1">// which allows team_size dependent allocations.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">team_shmem_size</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">team_size</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="n">team_size</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">           </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">160</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">set_scratch_size</span></code> function of the <a class="reference internal" href="../API/core/policies/TeamPolicy.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamPolicy</span></code></span></a> takes two or three arguments. The first argument specifies the level in the scratch hierarchy for which a specific size is requested. Different levels have different restrictions. Generally, the first level is restricted to a few tens of kilobytes roughly corresponding to L1 cache size. The second level can be used to get an aggregate over all teams of a few gigabyte, corresponding to available space in high-bandwidth memory. The third level mostly falls back to capacity memory in the node. The second and third argument are either per-thread or per-team sizes for scratch memory. Note like previously discussed, the setter function does not modify the instance it is called on, but returns a copy of the policy object with adjusted scratch size request.</p>
<p>Here are some examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">policy_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="p">).</span><span class="w"></span>
<span class="w">                          </span><span class="n">set_scratch_size</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">PerTeam</span><span class="p">(</span><span class="mi">1024</span><span class="p">),</span><span class="w"> </span><span class="n">PerThread</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span><span class="w"></span>
<span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">policy_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="p">).</span><span class="w"></span>
<span class="w">                          </span><span class="n">set_scratch_size</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">PerThread</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span><span class="w"></span>
<span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">policy_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="p">).</span><span class="w"></span>
<span class="w">                          </span><span class="n">set_scratch_size</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">PerTeam</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>The total amount of scratch space available for each team will be the per-team value plus the per-thread value multiplied by the team-size. The interface allows users to specify those settings inline:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">parallel_for</span><span class="p">(</span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="p">).</span><span class="n">set_scratch_size</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">PerTeam</span><span class="p">(</span><span class="mi">1024</span><span class="p">)),</span><span class="w"></span>
<span class="w">  </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;::</span><span class="n">member_type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">team</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>Instead of simply getting raw allocations in memory, users can also allocate Views directly in scratch memory. This is achieved by providing the shared memory handle as the first argument of the View constructor. Views also have a static member function which return their shared memory size requirements. The function expects the run-time dimensions as arguments, corresponding to View’s constructor. Note that the view must be unmanaged (i.e. it must have the <code class="docutils literal notranslate"><span class="pre">Unmanaged</span></code> memory trait).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">DefaultExecutionSpace</span><span class="o">::</span><span class="n">scratch_memory_space</span><span class="w"></span>
<span class="w">  </span><span class="n">ScratchSpace</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Define a view type in ScratchSpace</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">View</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">ScratchSpace</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">MemoryTraits</span><span class="o">&lt;</span><span class="n">Kokkos</span><span class="o">::</span><span class="n">Unmanaged</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">shared_int_2d</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Get the size of the shared memory allocation</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">shared_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_int_2d</span><span class="o">::</span><span class="n">shmem_size</span><span class="p">(</span><span class="n">team_size</span><span class="p">);</span><span class="w"></span>
<span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="n">team_size</span><span class="p">).</span><span class="w"></span>
<span class="w">                       </span><span class="n">set_scratch_size</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Kokkos</span><span class="o">::</span><span class="n">PerTeam</span><span class="p">(</span><span class="n">shared_size</span><span class="p">)),</span><span class="w"></span>
<span class="w">                     </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">member_type</span><span class="w"> </span><span class="n">team_member</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Get a view allocated in team shared memory.</span>
<span class="w">  </span><span class="c1">// The constructor takes the shared memory handle and the</span>
<span class="w">  </span><span class="c1">// runtime dimensions</span>
<span class="w">  </span><span class="n">shared_int_2d</span><span class="w"> </span><span class="nf">A</span><span class="p">(</span><span class="n">team_member</span><span class="p">.</span><span class="n">team_scratch</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">team_member</span><span class="p">.</span><span class="n">team_size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="nested-parallelism">
<h2>8.4 Nested parallelism<a class="headerlink" href="#nested-parallelism" title="Permalink to this heading">#</a></h2>
<p>Instead of writing code which explicitly uses league and team rank indices, one can use nested parallelism to implement hierarchical algorithms. Kokkos lets the user have up to three nested layers of parallelism. The team and thread levels are the first two levels. The third level is <em>vector</em> parallelism.</p>
<p>You may use any of the three parallel patterns – for, reduce, or scan – at each level<sup>1</sup>.
You may nest them and use them in conjunction with code that is aware of the league and team rank. The different layers are accessible via special execution policies: <code class="docutils literal notranslate"><span class="pre">TeamThreadLoop</span></code> and <code class="docutils literal notranslate"><span class="pre">ThreadVectorLoop</span></code>.</p>
<hr class="docutils" />
<p><sup>1</sup> The parallel scan operation is not implemented for all execution spaces on the thread level, and it doesn’t support a TeamPolicy on the top level.</p>
<hr class="docutils" />
<section id="team-loops">
<h3>8.4.1 Team loops<a class="headerlink" href="#team-loops" title="Permalink to this heading">#</a></h3>
<p>The first nested level of parallel loops splits an index range over the threads of a team. This motivates the policy name <a class="reference internal" href="../API/core/policies/TeamThreadRange.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamThreadRange</span></code></span></a>, which indicates that the loop is executed once by the team with the index range split over threads. The loop count is not limited to the number of threads in a team, and how the index range is mapped to threads is architecture dependent. It is not legal to nest multiple parallel loops using the <a class="reference internal" href="../API/core/policies/TeamThreadRange.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamThreadRange</span></code></span></a> policy. However, it is valid to have multiple parallel loops using the <a class="reference internal" href="../API/core/policies/TeamThreadRange.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamThreadRange</span></code></span></a> policy follow each other in sequence, in the same kernel. Note that it is not legal to make a write access to POD data outside the closure of a nested parallel layer. This is a conscious choice to prevent difficult-to-debug issues related to thread private, team shared and globally shared variables. A simple way to enforce this is by using the “capture by value”’ clause with lambdas,
but “capture by reference” is recommended for release builds since it typically results in better performance.
With the lambda being considered as <code class="docutils literal notranslate"><span class="pre">const</span></code> inside the <a class="reference internal" href="../API/core/policies/TeamThreadRange.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamThreadRange</span></code></span></a> loop, the compiler will catch illegal accesses at compile time as a <code class="docutils literal notranslate"><span class="pre">const</span></code> violation.</p>
<p>The simplest use case is to have another <a class="reference internal" href="../API/core/parallel-dispatch/parallel_for.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">parallel_for()</span></code></span></a> nested inside a kernel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_for</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamThreadRange</span><span class="p">;</span><span class="w"></span>

<span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="p">),</span><span class="w"></span>
<span class="w">                    </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="n">member_type</span><span class="w"> </span><span class="n">team_member</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Scalar</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="w"> </span><span class="p">(</span><span class="n">team_member</span><span class="p">,</span><span class="w"> </span><span class="n">loop_count</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">      </span><span class="c1">// tmp += i; // This would be an illegal access</span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../API/core/parallel-dispatch/parallel_reduce.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">parallel_reduce()</span></code></span></a>  construct can be used to perform optimized team-level reductions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_reduce</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamThreadRange</span><span class="p">;</span><span class="w"></span>
<span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="p">),</span><span class="w"></span>
<span class="w">                 </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="n">member_type</span><span class="w"> </span><span class="n">team_member</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The default reduction uses Scalar&#39;s += operator</span>
<span class="w">    </span><span class="c1">// to combine thread contributions.</span>
<span class="w">    </span><span class="n">Scalar</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">parallel_reduce</span><span class="w"> </span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="w"> </span><span class="p">(</span><span class="n">team_member</span><span class="p">,</span><span class="w"> </span><span class="n">loop_count</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">Scalar</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="n">lsum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="w">      </span><span class="p">},</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Introduce a team barrier here to synchronize threads</span>
<span class="w">    </span><span class="n">team_member</span><span class="p">.</span><span class="n">team_barrier</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// You may provide a custom reduction as a functor,</span>
<span class="w">    </span><span class="c1">// including one of the Kokkos-provided ones, e.g. Prod&lt;Scalar&gt;.</span>
<span class="w">    </span><span class="n">Scalar</span><span class="w"> </span><span class="n">product</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Scalar</span><span class="w"> </span><span class="n">init_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">parallel_reduce</span><span class="w"> </span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="w"> </span><span class="p">(</span><span class="n">team_member</span><span class="p">,</span><span class="w"> </span><span class="n">loop_count</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">Scalar</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="n">lsum</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="w">      </span><span class="p">},</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">Experimental</span><span class="o">::</span><span class="n">Prod</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">product</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>Note that custom reductions must employ one of the functor join patterns recognized by Kokkos; these include <code class="docutils literal notranslate"><span class="pre">Sum,</span> <span class="pre">Prod,</span> <span class="pre">Min,</span> <span class="pre">Max,</span> <span class="pre">LAnd,</span> <span class="pre">LOr,</span> <span class="pre">BAnd,</span> <span class="pre">BOr,</span> <span class="pre">ValLocScalar,</span> <span class="pre">MinLoc,</span> <span class="pre">MaxLoc,</span> <span class="pre">MinMaxScalar,</span> <span class="pre">MinMax,</span> <span class="pre">MinMaxLocScalar</span></code> and <code class="docutils literal notranslate"><span class="pre">MinMaxLoc</span></code>.</p>
<p>The third pattern is <a class="reference internal" href="../API/core/parallel-dispatch/parallel_scan.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">parallel_scan()</span></code></span></a> which can be used to perform prefix scans.</p>
<section id="team-barriers">
<h4>8.4.1.1 Team Barriers<a class="headerlink" href="#team-barriers" title="Permalink to this heading">#</a></h4>
<p>In instances where one loop operation might need to be sequenced with a different loop operation, such as filling of arrays as a preparation stage for following computations on that data, it is important to be able to control threads in time; this can be done through the use of barriers. In nested loops, the outside loop ( <a class="reference internal" href="../API/core/policies/TeamPolicy.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamPolicy&lt;&gt;</span> <span class="pre">()</span></code></span></a> ) has a built-in (implicit) team barrier; inner loops ( <a class="reference internal" href="../API/core/policies/TeamThreadRange.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamThreadRange</span> <span class="pre">()</span></code></span></a> ) do not. This latter condition is often referred to as a ‘non-blocking’ condition. When necessary, an explicit barrier can be introduced to synchronize team threads; an example is shown in the previous example.</p>
</section>
</section>
<section id="vector-loops">
<h3>8.4.2 Vector loops<a class="headerlink" href="#vector-loops" title="Permalink to this heading">#</a></h3>
<p>The innermost level of nesting parallel loops in a kernel comprises the <em>vector</em>-loop. Vector level parallelism works identically to the team level loops using the execution policy <a class="reference internal" href="../API/core/policies/ThreadVectorRange.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">ThreadVectorRange</span></code></span></a>. In contrast to the team-level, there is no legal way to exploit the vector level outside a parallel pattern using the <a class="reference internal" href="../API/core/policies/ThreadVectorRange.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">ThreadVectorRange</span></code></span></a>. However, one can use such a parallel construct in- and outside- of a <a class="reference internal" href="../API/core/policies/TeamThreadRange.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">TeamThreadRange</span></code></span></a> parallel operation.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_reduce</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamThreadRange</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">ThreadVectorRange</span><span class="p">;</span><span class="w"></span>
<span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">league_size</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="p">),</span><span class="w"></span>
<span class="w">                 </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="n">member_type</span><span class="w"> </span><span class="n">team_member</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">team_member</span><span class="p">.</span><span class="n">team_rank</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The default reduction uses Scalar&#39;s += operator</span>
<span class="w">    </span><span class="c1">// to combine thread contributions.</span>
<span class="w">    </span><span class="n">Scalar</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">parallel_reduce</span><span class="w"> </span><span class="p">(</span><span class="n">ThreadVectorRange</span><span class="w"> </span><span class="p">(</span><span class="n">team_member</span><span class="p">,</span><span class="w"> </span><span class="n">loop_count</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">Scalar</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="n">lsum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="w">      </span><span class="p">},</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="w"> </span><span class="p">(</span><span class="n">team_member</span><span class="p">,</span><span class="w"> </span><span class="n">workset_size</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// You may provide a custom reduction as a functor</span>
<span class="w">      </span><span class="c1">// including one of the Kokkos-provided ones, e.g., Prod&lt;Scalar&gt;.</span>
<span class="w">      </span><span class="n">Scalar</span><span class="w"> </span><span class="n">product</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">Scalar</span><span class="w"> </span><span class="n">init_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">parallel_reduce</span><span class="w"> </span><span class="p">(</span><span class="n">ThreadVectorRange</span><span class="w"> </span><span class="p">(</span><span class="n">team_member</span><span class="p">,</span><span class="w"> </span><span class="n">loop_count</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">Scalar</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// ...</span>
<span class="w">          </span><span class="n">lsum</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">Experimental</span><span class="o">::</span><span class="n">Prod</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">product</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>As the name indicates the vector-level must be vectorizable. The parallel patterns will exploit available mechanisms to encourage vectorization by the compiler. When using the Intel compiler for example, the vector level loop will be internally decorated with <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">ivdep</span></code>, telling the compiler to ignore assumed vector dependencies.</p>
</section>
<section id="restricting-execution-to-a-single-executor">
<h3>8.4.3 Restricting execution to a single executor<a class="headerlink" href="#restricting-execution-to-a-single-executor" title="Permalink to this heading">#</a></h3>
<p>As stated above, a kernel is a parallel region with respect to threads (and vector lanes) within a team. This means that global memory accesses outside of the respective nested levels potentially have to be protected against repetitive execution. A common example is the case where a team performs some calculation but only one result per team has to be written back to global memory.</p>
<p>Kokkos provides the <code class="docutils literal notranslate"><span class="pre">Kokkkos::single(Policy,Lambda)</span></code> function for this case. It currently accepts two policies:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Kokkos::PerTeam</span></code> restricts execution of the lambda’s body to once per team</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Kokkos::PerThread</span></code> restricts execution of the lambda’s body to once per thread (that is, to only one vector lane in a thread)</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">single</span></code> function takes a lambda as its second argument. That lambda takes zero arguments or one argument by reference. If it takes no argument, its body must perform side effects in order to have an effect. If it takes one argument, the final value of that argument is broadcast to every executor on the level: i.e. every vector lane of the thread, or every thread (and vector lane) of the team. It must always be correct for the lambda to capture variables by value (<code class="docutils literal notranslate"><span class="pre">[=]</span></code>, not <code class="docutils literal notranslate"><span class="pre">[&amp;]</span></code>). Thus, if the lambda captures by reference, it must <em>not</em> modify variables that it has captured by reference.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_for</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_reduce</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamThreadRange</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">ThreadVectorRange</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">PerThread</span><span class="p">;</span><span class="w"></span>

<span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="p">(...);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">member_type</span><span class="w"> </span><span class="n">team_member</span><span class="p">;</span><span class="w"></span>

<span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">policy</span><span class="p">,</span><span class="w"> </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">team_member</span><span class="o">&amp;</span><span class="w"> </span><span class="kr">thread</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="w"> </span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Perform a vector reduction with a thread</span>
<span class="w">      </span><span class="n">parallel_reduce</span><span class="w"> </span><span class="p">(</span><span class="n">ThreadVectorRange</span><span class="w"> </span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// ...</span>
<span class="w">          </span><span class="n">lsum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="w">      </span><span class="p">},</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Add the result value into a team shared array.</span>
<span class="w">      </span><span class="c1">// Make sure it is only added once per thread.</span>
<span class="w">      </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">single</span><span class="w"> </span><span class="p">(</span><span class="n">PerThread</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">shared_array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">parallel_reduce</span><span class="w"> </span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="w"> </span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="mi">99</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Add the result value into a team shared array.</span>
<span class="w">      </span><span class="c1">// Make sure it is only added once per thread.</span>
<span class="w">      </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">single</span><span class="w"> </span><span class="p">(</span><span class="n">PerThread</span><span class="w"> </span><span class="p">(</span><span class="kr">thread</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">lsum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">someFunction</span><span class="w"> </span><span class="p">(</span><span class="n">shared_array</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"></span>
<span class="w">                                </span><span class="n">shared_array</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Add the per team contribution to global memory.</span>
<span class="w">  </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">single</span><span class="w"> </span><span class="p">(</span><span class="n">PerTeam</span><span class="w"> </span><span class="p">(</span><span class="kr">thread</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">global_array</span><span class="p">(</span><span class="kr">thread</span><span class="p">.</span><span class="n">league_rank</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>Here is an example of using the broadcast capabilities to determine the start offset for a team in a buffer:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_for</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_reduce</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamThreadRange</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">ThreadVectorRange</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">PerThread</span><span class="p">;</span><span class="w"></span>

<span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="p">(...);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">TeamPolicy</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">member_type</span><span class="w"> </span><span class="n">team_member</span><span class="p">;</span><span class="w"></span>

<span class="n">Kokkos</span><span class="o">::</span><span class="n">View</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">offset</span><span class="p">(</span><span class="s">&quot;Offset&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">offset</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="n">parallel_for</span><span class="w"> </span><span class="p">(</span><span class="n">policy</span><span class="p">,</span><span class="w"> </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">team_member</span><span class="o">&amp;</span><span class="w"> </span><span class="kr">thread</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">parallel_reduce</span><span class="w"> </span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="w"> </span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(...)</span><span class="w"> </span><span class="n">lsum</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">single</span><span class="w"> </span><span class="p">(</span><span class="n">PerTeam</span><span class="w"> </span><span class="p">(</span><span class="kr">thread</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">my_offset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">my_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">atomic_fetch_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">offset</span><span class="p">(),</span><span class="n">lsum</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>To further illustrate the “parallel region” semantics of the team execution consider the following code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_reduce</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamThreadRange</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="p">;</span><span class="w"></span>

<span class="n">parallel_reduce</span><span class="p">(</span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">team_size</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">member_type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">teamMember</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">s</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">lsum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="p">},</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In this example <code class="docutils literal notranslate"><span class="pre">sum</span></code> will contain the value <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">*</span> <span class="pre">team_size</span> <span class="pre">*</span> <span class="pre">10</span></code>. Every thread in each team will compute <code class="docutils literal notranslate"><span class="pre">s=10</span></code> and then contribute it to the sum.</p>
<p>Let’s go one step further and add a nested <a class="reference internal" href="../API/core/parallel-dispatch/parallel_reduce.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">parallel_reduce()</span></code></span></a>. By choosing the loop bound to be <code class="docutils literal notranslate"><span class="pre">team_size</span></code> every thread still only runs once through the inner loop.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">parallel_reduce</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamThreadRange</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Kokkos</span><span class="o">::</span><span class="n">TeamPolicy</span><span class="p">;</span><span class="w"></span>

<span class="n">parallel_reduce</span><span class="p">(</span><span class="n">TeamPolicy</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">team_size</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">member_type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">teamMember</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">parallel_reduce</span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="p">(</span><span class="n">teamMember</span><span class="p">,</span><span class="w"> </span><span class="n">team_size</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">inner_lsum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">inner_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">inner_s</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">inner_lsum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">inner_s</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">},</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">lsum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="p">},</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The answer in this case is nevertheless <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">*</span> <span class="pre">team_size</span> <span class="pre">*</span> <span class="pre">team_size</span> <span class="pre">*</span> <span class="pre">10</span></code>. Each thread computes <code class="docutils literal notranslate"><span class="pre">inner_s</span> <span class="pre">=</span> <span class="pre">10</span></code>. But all threads in the team combine their results to compute a <code class="docutils literal notranslate"><span class="pre">s</span></code> value of <code class="docutils literal notranslate"><span class="pre">team_size</span> <span class="pre">*</span> <span class="pre">10</span></code>. Since every thread in each team contributes that value to the global sum, we arrive at the final value of <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">*</span> <span class="pre">team_size</span> <span class="pre">*</span> <span class="pre">team_size</span> <span class="pre">*</span> <span class="pre">10</span></code>. If the intended goal was for each team to only contribute <code class="docutils literal notranslate"><span class="pre">s</span></code> once to the global sum, the contribution should have been protected with a <code class="docutils literal notranslate"><span class="pre">single</span></code> clause.</p>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="Custom-Reductions.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">9. Custom Reductions</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="ParallelDispatch.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">7. Parallel dispatch</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2014, National Technology &amp; Engineering Solutions of Sandia, LLC (NTESS)
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            Contents
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">8. Hierarchical Parallelism</a><ul>
<li><a class="reference internal" href="#motivation">8.1 Motivation</a></li>
<li><a class="reference internal" href="#thread-teams">8.2 Thread teams</a><ul>
<li><a class="reference internal" href="#creating-a-policy-instance">8.2.1 Creating a Policy instance</a></li>
<li><a class="reference internal" href="#basic-kernels">8.2.2 Basic kernels</a></li>
</ul>
</li>
<li><a class="reference internal" href="#team-scratch-pad-memory">8.3 Team scratch pad memory</a></li>
<li><a class="reference internal" href="#nested-parallelism">8.4 Nested parallelism</a><ul>
<li><a class="reference internal" href="#team-loops">8.4.1 Team loops</a><ul>
<li><a class="reference internal" href="#team-barriers">8.4.1.1 Team Barriers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vector-loops">8.4.2 Vector loops</a></li>
<li><a class="reference internal" href="#restricting-execution-to-a-single-executor">8.4.3 Restricting execution to a single executor</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    </body>
</html>